# Строки - краткий обзор


Давайте кратко рассмотрим природу строк Python.

Прежде всего, строки Python (или просто строки, поскольку мы не будем обсуждать строки других языков) являются **неизменяемыми последовательностями**.

Это очень важно отметить, потому что это означает, что от них следует ожидать знакомого поведения.

```python
# Пример 1

word = 'by'
print(len(word))


# Пример 2

empty = ''
print(len(empty))


# Пример 3

i_am = 'I\'m'
print(len(i_am))

```

Давайте проанализируем код, чтобы понять, о чем мы говорим:

*   Взгляните на **Пример 1**. Функция `len()`, используемая для строк, возвращает количество символов, содержащихся в аргументах. Программа выводит `2`.
*   Любая строка может быть пустой. Тогда ее длина будет `0` - как в **Примере 2**.
*   Не забывайте, что обратная косая черта (`\`), используемая в качестве escape-символа, не включается в общую длину строки. Таким образом, код в **Примере 3** выводит `3`.

Запустите три примера кода и проверьте.


# Множественные строки


Сейчас очень хороший момент, чтобы показать Вам другой способ определения строк в исходном коде Python. Обратите внимание, что синтаксис, который Вы уже знаете, не позволит Вам использовать строку, занимающую более одной строки текста.

По этой причине этот код ошибочен:

```
[!mark!]
multiLine = 'Line #1
Line #2'

print(len(multiLine))
[!/mark!]

```

К счастью, для этих типов строк Python предлагает отдельный, удобный и простой синтаксис. Вот как это выглядит.

```python
multiLine = '''Line #1
Line #2'''

print(len(multiLine))

```

Как видите, строка начинается с **трех апострофов**, а не с одного. Тот же тройной апостроф используется для ее завершения.

Количество текстовых строк, помещаемых внутри такой строки, является произвольным.

Фрагмент выводит `15`.

Внимательно посчитайте символы. Является ли этот результат правильным или нет? На первый взгляд, все выглядит хорошо, но, когда Вы подсчитываете символы, это не так.

`Line #1` содержит семь символов. Две такие строки содержат 14 символов. Мы потеряли символ? Где? Как?

Нет, не потеряли.

**Пропавший символ просто невидим - это конец строки**. Он расположен между двумя текстовыми строками.

Он обозначается как: `\n`.


Помните? Это специальный (управляющий) символ, используемый для **перевода строки** (отсюда и его название: LF). Вы не можете видеть это, но это имеет значение.

Множественные строки также могут быть разделены **тройными кавычками**, как здесь:

```python
multiLine = """Line #1
Line #2"""

print(len(multiLine))

```

Выберите наиболее удобный для Вас метод. Оба работают одинаково.


# Работа со строками


Как и другие виды данных, строки имеют свой собственный набор допустимых операций, хотя они довольно ограничены по сравнению с числами.

В общем случае строки могут быть:

*   **объединенными** (соединенными);
*   **реплицированными**.


Первая операция выполняется оператором `+` (примечание: это не сложение), а вторая - оператором `*` (обратите внимание: это не умножение).

Возможность использовать один и тот же оператор для совершенно разных типов данных (например, чисел и строк) называется **перегрузкой** (так как такой оператор перегружен различными дополнительными обязанностями).

```python
str1 = 'a'
str2 = 'b'

print(str1 + str2)
print(str2 + str1)
print(5 * 'a')
print('b' * 4)

```

Проанализируйте пример.

*   Оператор `+`, используемый при соединении двух или более строк, создает новую строку, содержащую все символы из своих аргументов (примечание: порядок имеет значение - перегруженный `+`, в отличие от использования в варианте с числами **не коммутативен**)
*   Оператору `*` нужны строка и число в качестве аргументов; в этом случае порядок не имеет значения - вы можете поставить число перед строкой или наоборот, результат будет таким же - новая строка, созданная n-й репликацией строки аргумента.

Код выдает следующий вывод:

```
ab
ba
aaaaa
bbbb
```

Примечание: варианты сокращенных вышеперечисленных операторов также применимы для строк (`+=` и `*=`).

  
# Работа со строками: `ord()`


Если Вы хотите **узнать значение ASCII/UNICODE кода определенного символа**, Вы можете использовать функцию с именем ord() (как _порядковый номер_).

Функции в качестве аргумента нужна **односимвольная строка** - нарушение этого требования приводит к вызову исключения TypeError, и возвращает число, которое представляет код символа аргумента.

```python
# Пример функции ord()

ch1 = 'a' 
ch2 = ' ' # пробел

print(ord(ch1))
print(ord(ch2))

```

Посмотрите на код и запустите его. Вывод программы:

```
97
32
```


Теперь присвойте различные значения `ch1` и `ch2`, например, `α` (греческая альфа) и `ę` (буква в польском алфавите); затем запустите код и посмотрите, какой результат он выводит. Проведите свои собственные эксперименты.

  
# Работа со строками: `chr()`


Если Вы знаете кодовую позицию (число) и хотите получить соответствующий символ, Вы можете использовать функцию с именем `chr()`.

Функция **принимает кодовую позицию и возвращает ее символ**.

Ее вызов с неверным аргументом (например, отрицательный или неверный код) вызывает исключения `ValueError` или `TypeError`.

```python
# Пример функции chr()

print(chr(97))
print(chr(945))

```

Запустите код. Программа выводит:

```
a
α
```


Примечание:

*   `chr(ord(x)) == x`
*   `ord(chr(x)) == x`

И снова, проведите свои собственные эксперименты.

  
# Строки как последовательности: индексирование


Ранее мы говорили, что **строки Python являются последовательностями**. Пришло время показать Вам, что это на самом деле означает.

Строки не являются списками, но **Вы можете рассматривать их как списки во многих частных случаях**.

Например, если Вы хотите получить доступ к любому из символов строки, Вы можете сделать это с помощью **индексации**, как в примере. Запустите программу.

```python
# Индексирование строк

the_string = 'silly walks'

for ix in range(len(the_string)):
    print(the_string[ix], end=' ')

print()

```

Будьте осторожны - не пытайтесь выйти за пределы строки - это вызовет исключение.

Пример вывода:

```
s i l l y  w a l k s
```


Кстати, отрицательные значения индекса тоже работают. Проверьте это сами.


## Строки как последовательности: итерация


**Итерация по строкам** тоже работает. Посмотрите на пример ниже:

```python
# Итерация по строкам

the_string = 'silly walks'

for character in the_string:
    print(character, end=' ')

print()

```

Вывод такой же, как и ранее. Проверьте.


# Срезы


Кроме того, все, что Вы знаете о **срезах**, все еще можно использовать.

Мы собрали несколько примеров, показывающих, как срезы работают в мире строк. Посмотрите на код, проанализируйте его и запустите.

```python
# Срезы

alpha = "abdefg"

print(alpha[1:3])
print(alpha[3:])
print(alpha[:3])
print(alpha[3:-2])
print(alpha[-3:4])
print(alpha[::2])
print(alpha[1::2])

```

В этом примере вы не увидите ничего нового, но мы хотим, чтобы Вы были уверены, что Вы понимаете строки кода.

Вывод кода:

```
bd
efg
abd
e
e
adf
beg
```

Проведите собственный эксперимент.

  
  
# Операторы in и not in


## Оператор `in`

Оператор `in` не должен удивить Вас при работе со строками - он просто **проверяет, находится ли его левый аргумент (первая строка) в любом месте в пределах правого аргумента (вторая строка)**.

Результат проверки - `True` или `False`.

Посмотрите на пример программы. Вот как работает оператор `in`.

```python
alphabet = "abcdefghijklmnopqrstuvwxyz"

print("f" in alphabet)
print("F" in alphabet)
print("1" in alphabet)
print("ghi" in alphabet)
print("Xyz" in alphabet)

```

Пример вывода:

```
True
False
False
True
False
```


## Оператор `not in`

Как Вы, вероятно, понимаете, оператор `not in` также можно использовать.

Вот как это работает:

```python
alphabet = "abcdefghijklmnopqrstuvwxyz"

print("f" not in alphabet)
print("F" not in alphabet)
print("1" not in alphabet)
print("ghi" not in alphabet)
print("Xyz" not in alphabet)

```

Примерный вывод будет следующим:

```
False
True
True
False
True
```


# Строки в Python неизменяемы


Как ранее было сказано, что **строки в Python являются неизменяемыми**. Это очень важная особенность. Что это значит?

Это в первую очередь означает, что сходство строк и списков ограничено. Не все, что Вы можете сделать со списком, может быть сделано со строкой.

Первое важное различие **не позволяет использовать инструкцию `del` для удаления чего-либо из строки**.

Код, который не будет работать:

```
[!mark!]
alphabet = "abcdefghijklmnopqrstuvwxyz"
del alphabet[0]
[!/mark!]

```  

Единственное, что Вы можете делать инструкцией `del` со строкой, это **удалить строку целиком**. Попробуйте сделать это.


В строках Python **нет метода `append()`** - Вы не можете их расширять никаким образом.

Пример ниже ошибочен:

```
[!mark!]
alphabet = "abcdefghijklmnopqrstuvwxyz"
alphabet.append("A")
[!/mark!]

```
 

При отсутствии метода `append()` метод **`insert()` также нельзя использовать**:

```
[!mark!]
alphabet = "abcdefghijklmnopqrstuvwxyz"
alphabet.insert(0, "A")
[!/mark!]

```


Не думайте, что неизменяемость строки ограничивает Ваши возможности работать со строками.

Единственное последствие - Вы должны помнить об этом и реализовывать свой код немного по-другому - посмотрите на пример кода.

```python
alphabet = "bcdefghijklmnopqrstuvwxy"

alphabet = "a" + alphabet
alphabet = alphabet + "z"

print(alphabet)

```

Эта форма кода полностью приемлема, будет работать без нарушения правил Python и выведет на экран полный латинский алфавит:

```
abcdefghijklmnopqrstuvwxyz
```


Вы можете спросить, ухудшает ли **создание новой копии строки каждый раз при изменении ее содержимого эффективность кода**.

Да, это так. Немного. Впрочем, это не проблема.


# Работа со строками: `min()`


Теперь, когда Вы понимаете, что строки являются последовательностями, мы можем показать Вам некоторые менее очевидные возможности последовательностей. Мы представим их с использованием строк, но не забывайте, что списки могут использовать те же приемы.

Давайте начнем с функции с именем `min()`.

Функция **находит наименьший элемент последовательности, переданной в качестве аргумента**. Есть одно условие - последовательность (строка, список, это не имеет значения) **не может быть пустой**, иначе Вы получите исключение `ValueError`.

```python
# Функция min() - Пример 1:
print(min("aAbByYzZ"))


# Функция min() - Примеры 2 и 3:
t = 'The Knights Who Say "Ni!"'
print('[' + min(t) + ']')

t = [0, 1, 2]
print(min(t))

```

Программа **Пример 1** выводит:

```
A
```


Примечание. Это _A_ в верхнем регистре. Зачем? Вспомните таблицу ASCII - какие буквы занимают первые позиции - заглавные или строчные?

Мы подготовили еще два примера для анализа: **Примеры 2 и 3**.

Как видите, они представляют собой больше, чем просто строки. Ожидаемый результат выглядит следующим образом:

```
[ ]
0
```

Примечание. Мы использовали квадратные скобки, чтобы не пропускать пробел на экране.


# Работа со строками: `max()`


Аналогичным образом функция с именем `max()` **находит наибольший элемент последовательности**.

```python
# Функция max() - Пример 1
print(max("aAbByYzZ"))


# Функция max() - Примеры 2 и 3
t = 'The Knights Who Say "Ni!"'
print('[' + max(t) + ']')

t = [0, 1, 2]
print(max(t))

```

Посмотрите на **Пример 1**. Программы выводит:

```
z
```


Примечание: это строчная буква _z_.

Теперь давайте посмотрим на функцию `max()`, применяемую к тем же данным, что и ранее. Посмотрите на **Примеры 2 и 3**.

Ожидаемый результат:

```
[y]
2
```

Проведите свои собственные эксперименты.

  
# Работа со строками: метод `index()`


Метод `index()` (это именно метод, не функция) **ищет в последовательности первый элемент со значением, указанным в его аргументе**.

Примечание: искомый элемент должен присутствовать в последовательности - **его отсутствие вызовет исключение `ValueError`**.

Метод возвращает индекс **первого появления аргумента**(что означает, что наименьший возможный результат - 0, а наибольший - длина аргумента уменьшенная на 1).

```python
# Пример метода index()
print("aAbByYzZaA".index("b"))
print("aAbByYzZaA".index("Z"))
print("aAbByYzZaA".index("A"))

```

Программа выводит:

```
2
7
1
```  
  

# Работа со строками: функция `list()`


Функция `list()` **принимает аргумент (строку) и создает новый список, содержащий все символы строки, по одному на элемент списка**.

Примечание: это не строго строковая функция - `list()` может создавать новый список из множества других объектов (например, из кортежей и словарей).

Посмотрите на пример кода.

```python
# Пример функции list()
print(list("abcabc"))

```

Пример выводит:

```
['a', 'b', 'c', 'a', 'b', 'c']
```


## Работа со строками: метод `count()`


Метод `count()` **подсчитывает все появления элемента в последовательности**. Отсутствие таких элементов не вызывает никаких проблем.

Посмотрите на пример. Можете угадать его вывод?

```python
# Пример метода count()
print("abcabc".count("b"))
print('abcabc'.count("d"))

```

Он будет таков:

```
2
0
```

Кроме того, строки Python имеют значительное количество методов, предназначенных исключительно для обработки символов. Не ожидайте, что они будут работать с любыми другими наборами данных. Полный список представлен здесь: [https://docs.python.org/3.4/library/stdtypes.html#string-methods](https://docs.python.org/3.4/library/stdtypes.html#string-methods).

Мы собираемся показать Вам те, которые мы считаем наиболее полезными.

  
# Основные тезисы


1. Строки в Python являются **неизменяемыми последовательностями** и могут индексироваться, срезаться и повторяться, как и любая другая последовательность, а также использоваться вместе с операторами `in` и `not in`. В Python есть два типа строк:

   *   **одиночные** строки, которые не могут пересекать границы строк - мы обозначаем их апострофами (`'string'`) или кавычками (`"string"`)
   *   **множественные** строки, занимающие более одной строки исходного кода, разделенные триграфами:  
      
       ```
       '''
       string
       '''
       ```  
    
       или
    
       ```
       """
       string
       """
       ```


2. Длина строки определяется функцией `len()`. Управляющий символ (`\`) не учитывается. Например:
    
    ```python
    print(len("\n\n"))
    
    ```  
    
    выводит `2`.


3. Строки можно **объединить** с помощью оператора `+` и **реплицировать** с помощью оператора `*`. Например:
    
    ```python
    asterisk = '*'
    plus = "+"
    decoration = (asterisk + plus) * 4 + asterisk
    print(decoration)
    
    ```
    
    выводит `*+*+*+*+*`.


4. Пара функций `chr()` и `ord()` может использоваться для создания символа с использованием его кодовой позиции и для определения кодовой позиции, соответствующей символу. Оба следующих выражения всегда верны:
    
    ```
    chr(ord(character)) == character
    ord(chr(codepoint)) == codepoint
    
    ```  

5. Некоторые другие функции, которые могут быть применены к строкам:

   *   `list()` – создает список, состоящий из всех символов строки;
   *   `max()` – находит символ с наибольшим кодом;
   *   `min()` – находит символ с наименьшим кодом.


6. Метод с именем `index()` находит индекс заданной подстроки внутри строки.


---

**Упражнение 1**

Какова длина следующей строки при условии, что между кавычками нет пробелов?

```
"""
"""
```

<details><summary>Проверка</summary>

1

</details>

---

**Упражнение 2**

Каков ожидаемый вывод следующего кода?

```python
s = 'yesteryears'
the_list = list(s)
print(the_list[3:6])

```

<details><summary>Проверка</summary>

`['t', 'e', 'r']`

</details>

---

**Упражнение 3**

Каков ожидаемый вывод следующего кода?

```python
for ch in "abc":
    print(chr(ord(ch) + 1), end='')

```

<details><summary>Проверка</summary>

`bcd`

</details>

