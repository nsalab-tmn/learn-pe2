# Шифр Цезаря: шифрование сообщения


Мы собираемся показать Вам четыре простые программы, чтобы представить аспекты обработки строк в Python. Они целенаправленно просты, лабораторные задачи будут значительно сложнее.

Первая задача, которую мы хотим показать Вам, называется **Шифр Цезаря** - подробнее здесь: [https://ru.wikipedia.org/wiki/Шифр_Цезаря](https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%A6%D0%B5%D0%B7%D0%B0%D1%80%D1%8F).

Этот шифр был (вероятно) изобретен и использован Гаем Юлием Цезарем и его войсками во время Галльских войн. Идея довольно проста - каждая буква сообщения заменяется ближайшим последующим (_A_ становится _B_, _B_ становится _C_ и т.д.) Единственное исключение - _Z_, которое становится _A_.

Программа является очень простой (но работающей) реализацией алгоритма.

```python
# Шифр Цезаря.
text = input("Введите сообщение: ")
cipher = ''
for char in text:
    if not char.isalpha():
        continue
    char = char.upper()
    code = ord(char) + 1
    if code > ord('Z'):
        code = ord('A')
    cipher += chr(code)

print(cipher)

```

Мы написали ее, используя следующие предположения:

*   она принимает только латинские буквы (примечание: римляне не использовали ни пробелы, ни цифры);
*   все буквы сообщения находятся в верхнем регистре (примечание: римляне знали только заглавные буквы).

Давайте проследим код:

*   строка 02: попросим пользователя ввести не зашифрованное, однострочное сообщение;
*   строка 03: создадим строку для зашифрованного сообщения (пока пустую);
*   строка 04: начать замены в сообщении;
*   строка 05: если текущий символ не является алфавитным...
*   строка 06: ... проигнорировать его;
*   строка 07: преобразовать букву в верхний регистр (желательно делать это всегда, а не проверять, нужно это или нет);
*   строка 08: получить код буквы и увеличить его на единицу;
*   строка 09: если полученный код имеет "окончания" латинского алфавита (если он больше, чем код _Z_)...
*   строка 10: ... изменить его на код _A_;
*   строка 11: добавить полученный символ в конец зашифрованного сообщения;
*   строка 13: напечатайте зашифрованное сообщение.

Код, переданный с этим сообщением:

```
AVE CAESAR
```  

Вывод:

```
BWFDBFTBS
```

Проведите собственное тестирование.

  
# Шифр Цезаря: расшифровка сообщения


Обратное преобразование теперь должно быть для Вас ясным - давайте просто представим Вам код как есть, без каких-либо объяснений.

```python
# Шифр Цезаря - расшифровка сообщения.
cipher = input('Введите зашифрованное сообщение: ')
text = ''
for char in cipher:
    if not char.isalpha():
        continue
    char = char.upper()
    code = ord(char) - 1
    if code < ord('A'):
        code = ord('Z')
    text += chr(code)

print(text)

```

Посмотрите на код. Проверьте внимательно, работает ли он. Используйте шифрованное сообщение из предыдущей программы.


# Обработчик цифр


В третьей программе показан простой метод, позволяющий вводить строки, заполненные числами, и легко их обрабатывать. Примечание: функция `input()` в сочетании с функциями `int()` или `float()` не подходит для этой цели.

Обработка будет чрезвычайно простой - мы хотим, чтобы числа были суммированы.

```python
# Обработчик цифр.

line = input("Введите числа в строку, разделяя пробелами: ")
strings = line.split()
total = 0
try:
    for substr in strings:
        total += float(substr)
    print("Сумма:", total)
except:
    print(substr, "это не число.")

```

Посмотрите на код. Давайте проанализируем его.

Понимание списков может сделать код более компактным. Можете сделать это, если хотите.

Давайте рассмотрим нашу версию:

*   строка 03: просим пользователя ввести строку, заполненную любым количеством чисел (числа могут быть числами с плавающей запятой);
*   строка 04: разбиваем строку, на список подстрок;
*   строка 05: определяем общую сумму как ноль;
*   строка 06: поскольку преобразование string-float может вызвать исключение, лучше реализовать защиту с помощью блока try-exept;
*   строка 07: итерируемся по списку...
*   строка 08: ... и попробуем преобразовать все его элементы в числа с плавающей точкой; если это работает успешно, увеличиваем значение суммы;
*   строка 09: пока все хорошо, поэтому выведите значение суммы;
*   строка 10: программа должна закончится в этом месте в случае ошибки;
*   строка 11: выводим диагностическое сообщение, показывающее пользователю причину сбоя.

Код имеет один важный недостаток - он отображает фиктивный результат, когда пользователь вводит пустую строку. Можете исправить это?


# Валидатор IBAN


Четвертая программа реализует (в несколько упрощенной форме) алгоритм, используемый европейскими банками для указания номеров счетов. Стандарт под названием **IBAN** (международный номер банковского счета) предоставляет простой и достаточно надежный метод проверки номеров счетов по простым опечаткам, которые могут возникнуть при переписывании номера, например, из бумажных документов, таких как счета или чеки в компьютер.

Вы можете найти более подробную информацию здесь: [https://ru.wikipedia.org/wiki/IBAN](https://ru.wikipedia.org/wiki/IBAN).

IBAN-совместимый номер счета состоит из:

*   двухбуквенный код страны, взятый из стандарта ISO 3166-1 (например, _FR_ для Франции, _GB_ для Великобритании, _DE_ для Германии и т.д.);
*   две контрольные цифры, используемые для проверки достоверности - быстро и просто, но это не очень надежный тест, проверяющий, является число некорректным (искаженным опечаткой) или корректным;
*   фактический номер счета (до 30 буквенно-цифровых символов - длина этой части зависит от страны).

Стандарт гласит, что проверка требует следующих шагов (согласно Википедии):

*   (шаг 1) Проверьте правильность общей длины IBAN в соответствии со страной (эта программа этого не сделает, но Вы можете изменить код, чтобы он соответствовал этому требованию, если хотите; примечание: Вы должны научить программу длинам кодов всех стран, используемых в Европе);
*   (шаг 2) Переместить четыре начальных символа в конец строки (т.е. код страны и контрольные цифры);
*   (шаг 3) Заменить каждую букву в строке двумя цифрами, расширив тем самым строку, где _A = 10_, _B = 11_... _Z = 35_;
*   (шаг 4) Интерпретировать строку как десятичное целое число и вычислить остаток от этого числа при делении на 97; Если остаток равен 1, тест контрольной цифры пройден и IBAN может быть верным.

```python
# Валидатор IBAN.

iban = input("Введите IBAN: ")
iban = iban.replace(' ','')

if not iban.isalnum():
    print("Вы ввели некорректные символы.")
elif len(iban) < 15:
    print("Введенный IBAN слишком короткий.")
elif len(iban) > 31:
    print("Введенный IBAN слишком длинный.")
else:
    iban = (iban[4:] + iban[0:4]).upper()
    iban2 = ''
    for ch in iban:
        if ch.isdigit():
            iban2 += ch
        else:
            iban2 += str(10 + ord(ch) - ord('A'))
    iban = int(iban2)
    if iban % 97 == 1:
        print("IBAN корректный.")
    else:
        print("IBAN не корректный.")

```

Посмотрите на код. Давайте проанализируем его:

*   строка 03: попросить пользователя ввести IBAN (число может содержать пробелы, поскольку они значительно улучшают читабельность номера...
*   строка 04: ... но удалить их);
*   строка 05: введенный IBAN должен состоять только из цифр и букв - если это не так...
*   строка 06: ... вывести сообщение;
*   строка 07: IBAN не должен быть короче 15 символов (это самый короткий вариант, используемый в Норвегии);
*   строка 08: если он короче, сообщить об этом пользователю;
*   строка 09: кроме того, IBAN не может быть длиннее 31 символа (это самый длинный вариант, используемый на Мальте);
*   строка 10: если он длиннее, вывести предупреждение;
*   строка 11: начать фактическую обработку;
*   строка 12: переместить четыре начальных символа в конец числа и преобразовать все буквы в верхний регистр (шаг 02 алгоритма);
*   строка 13: это переменная, используемая для полного числа, созданная путем замены букв цифрами (в соответствии с шагом 03 алгоритма);
*   строка 14: перебирать все символы IBAN;
*   строка 15: если символ является цифрой...
*   строка 16: просто скопировать ее;
*   строка 17: в противном случае...
*   строка 18: ... преобразовывать его в две цифры (обратите внимание, как это делается в примере);
*   строка 19: преобразованная форма IBAN готова - сделайте из нее целое число;
*   строка 20: остаток от деления `iban2` на `97` равен `1`?
*   строка 21: если да, то успех;
*   строка 22: в противном случае...
*   строка 23: ... номер недействителен.

Давайте добавим некоторые тестовые данные (все эти числа действительны - Вы можете сделать их недействительными, изменив любой символ).

*   British: `GB72 HBZU 7006 7212 1253 00`
*   French: `FR76 30003 03620 00020216907 50`
*   German: `DE02100100100152517108`

Если Вы являетесь резидентом ЕС, Вы можете использовать свой номер счета для тестов.

  
# Основные тезисы


1. Строки являются ключевыми инструментами в современной обработке данных, поскольку наиболее полезными данными на самом деле являются именно строки. Например, при использовании поисковой машины в Интернете (которая в наши дни кажется довольно тривиальной) используется чрезвычайно сложная обработка строк, включающая невообразимые объемы данных.

2. Строгое сравнение строк (как это делает Python) может быть очень неудовлетворительным, когда дело доходит до расширенного поиска (например, во время обширных запросов к базе данных). В ответ на это требование было создано и реализовано несколько алгоритмов сравнения _нечетких_ строк. Эти алгоритмы могут находить строки, которые не равны в смысле Python, но **похожи**.
    
    Одним из таких понятий является **расстояние Хэмминга**, которое используется для определения сходства двух строк. Если Вас интересует эта проблема, Вы можете узнать о ней больше здесь: [Расстояние Хэмминга](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%A5%D1%8D%D0%BC%D0%BC%D0%B8%D0%BD%D0%B3%D0%B0). Другое решение того же типа, но основанное на другом предположении, - это **расстояние Левенштейна**, описанное здесь: [Расстояние Левенштейна](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%9B%D0%B5%D0%B2%D0%B5%D0%BD%D1%88%D1%82%D0%B5%D0%B9%D0%BD%D0%B0).


3. Другой способ сравнения строк - найти их _акустическое_ сходство, что означает процесс, ведущий к определению, похожи ли две строки по звучанию (например, "raise" и "race"). Такое сходство необходимо устанавливать для каждого языка (или даже диалекта) в отдельности.

    Алгоритм, используемый для такого сравнения для английского языка, называется **Soundex** и был изобретен - вы не поверите - в 1918 году. Подробнее о нем можно узнать здесь: [Soundex](https://ru.wikipedia.org/wiki/Soundex).


4. Из-за ограниченной точности данных с плавающей запятой и целых чисел иногда целесообразно хранить и обрабатывать огромные числовые значения в виде строк. Это метод, который использует Python, когда Вы заставляете его работать с целым числом, состоящим из очень большого количества цифр.




