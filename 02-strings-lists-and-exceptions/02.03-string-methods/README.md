# Метод `capitalize()`


Давайте рассмотрим некоторые стандартные строковые методы Python. Мы рассмотрим их в алфавитном порядке - если честно, любой порядок имеет столько же недостатков, сколько и преимуществ, поэтому выбор может быть и случайным.

Метод `capitalize()` делает именно то, о чем говорит его название - **он создает новую строку, заполненную символами, взятыми из исходной строки**, но пытается изменить их в следующим образом:

*   **если первый символ в строке является буквой** (примечание: первый символ - это элемент с индексом, равным `0`, не только первый видимый символ), **он будет преобразован в верхний регистр**;
*   **все оставшиеся буквы в строке будут преобразованы в строчные**.


Не забывайте об этом:

*   исходная строка (из которой вызывается метод) никоим образом не изменяется (неизменность строки должна соблюдаться без оговорок);
*   измененная (в данном случае с первой заглавной буквой) строка возвращается в результате - если Вы не используете ее каким-либо образом (не присваиваете ее переменной или не передаете в функцию/метод), она исчезает без следа.


Примечание: методы не должны вызываться только из переменных. Они могут быть вызваны непосредственно из строковых литералов. Мы будем регулярно использовать эту конвенцию - это упростит примеры, так как наиболее важные аспекты не исчезнут среди ненужных назначений.

Посмотрите на пример. Запустите его.

```python
# Пример метода capitalize()
print('aBcD'.capitalize())

```

Вот что он выводит:

```
Abcd
```


Попробуйте несколько более сложных примеров и протестируйте их вывод:

```python
print("Alpha".capitalize())
print('ALPHA'.capitalize())
print(' Alpha'.capitalize())
print('123'.capitalize())
print("αβγδ".capitalize())

```

# Метод `center()`


Вариант с одним параметром метода `center()` **создает копию исходной строки, пытаясь отцентрировать ее в поле указанной ширины**.

Центрирование фактически выполняется путем **добавления пробелов перед и после строки**.

Не ожидайте, что этот метод продемонстрирует какие-либо сложные умения. Он довольно простой.


Код в примере использует скобки, чтобы четко показать Вам, где центрированная строка фактически начинается и заканчивается.

```python
# Пример метода center()
print('[' + 'alpha'.center(10) + ']')

```

Его вывод выглядит следующим образом:

```
[  alpha   ]
```

Если длина целевого поля слишком мала, чтобы поместиться в строку, возвращается исходная строка.

Вы можете увидеть метод `center()` в других примерах:

```python
print('[' + 'Beta'.center(2) + ']')
print('[' + 'Beta'.center(4) + ']')
print('[' + 'Beta'.center(6) + ']')

```

Запустите коды выше и проверьте, какой вывод они дают.


**Вариант `center()` с двумя параметрами использует символ из второго аргумента вместо пробела**. Проанализируйте пример ниже:

```python
print('[' + 'gamma'.center([!mark!]20, '*'[!/mark!]) + ']')

```

Вот почему вывод теперь выглядит так:

```
[*******gamma********]
```

Проведите больше экспериментов.


# Метод `endswith()`


Метод `endswith()` **проверяет, заканчивается ли данная строка указанным аргументом, и возвращает `True` или `False`**, в зависимости от результата проверки.

Примечание: подстрока должна соответствовать последнему символу строки - она не может быть просто расположена где-то близко к концу строки.

```python
# Пример метода endswith():
if "epsilon".endswith("on"):
    print("yes")
else:
    print("no")

```

Посмотрите на наш пример, проанализируйте его и запустите. Он выводит:

```
yes
```


Теперь Вы должны быть в состоянии предсказать вывод кода ниже:

```python
t = "zeta"
print(t.endswith("a"))
print(t.endswith("A"))
print(t.endswith("et"))
print(t.endswith("eta"))

```

Запустите код, чтобы проверить свои прогнозы.


# Метод `find()`


Метод `find()` похож на метод `index()`, который Вы уже знаете - **ищет подстроку и возвращает индекс первого появления этой подстроки**, но:

*   он безопаснее - он **не генерирует ошибку для аргумента, содержащего несуществующую подстроку** (возвращается `-1`);
*   он **работает только со строками** - не пытайтесь применить его к какой-либо другой последовательности.

```python
# Пример метода find()
print("Eta".find("ta"))
print("Eta".find("mma"))

```

Посмотрите на код. Вот как Вы можете его использовать.

Код печатает:

```
1
-1
```

Примечание: не используйте `find()`, если Вы только хотите проверить, встречается ли один символ в строке - оператор `in` будет значительно быстрее.

Вот еще один пример:

```python
t = 'theta'
print(t.find('eta'))
print(t.find('et'))
print(t.find('the'))
print(t.find('ha'))

```

Можете ли Вы предсказать вывод? Запустите его и проверьте свои прогнозы.


Если Вы хотите выполнить поиск не с начала строки, а с **любой позиции**, Вы можете использовать **двухпараметрический вариант** `find()`. Посмотрите на пример:

```python
print('kappa'.find([!mark!]'a', 2[!/mark!]))

```

Второй аргумент **указывает индекс, с которого начинается поиск** (он необязательно должен быть меньше длины строки).

Среди двух букв _a_ будет найдена только вторая. Запустите код и проверьте.


Вы можете использовать метод `find()` для поиска всех появлений подстроки, например:

```python
the_text = """A variation of the ordinary lorem ipsum
text has been used in typesetting since the 1960s 
or earlier, when it was popularized by advertisements 
for Letraset transfer sheets. It was introduced to 
the Information Age in the mid-1980s by the Aldus Corporation, 
which employed it in graphics and word-processing templates
for its desktop publishing program PageMaker (from Wikipedia)"""

fnd = the_text.find('the')
while fnd != -1:
    print(fnd)
    fnd = the_text.find('the', fnd + 1)

```

Код выводит индексы всех появлений артикля _the_, и его вывод выглядит так:

```
15
80
198
221
238
```

Существует также **трехпараметрический вариант метода `find()`** - третий аргумент **указывает на первый индекс, который не будет учитываться при поиске** (на самом деле это верхний предел поиска).

Посмотрите на наш пример ниже:

```python
print('kappa'.find('a', 1, 4))
print('kappa'.find('a', 2, 4))

```

Второй аргумент указывает индекс, с которого начинается поиск (он необязательно должен быть меньше длины строки).

Следовательно, измененный пример выводит:

```
1
-1
```

_a_ нельзя найти в заданных границах поиска во втором `print()`.


# Метод `isalnum()`


Метод без параметров с именем `isalnum()` **проверяет, содержит ли строка только цифры или символы алфавита (буквы), и возвращает `True` или `False`** в зависимости от результата.

Посмотрите на код в примере и запустите его.

```python
# Пример метода isalnum():
print('lambda30'.isalnum())
print('lambda'.isalnum())
print('30'.isalnum())
print('@'.isalnum())
print('lambda_30'.isalnum())
print(''.isalnum())

```

Примечание: любой строковый элемент, который не является цифрой или буквой, заставляет метод возвращать `False`. Пустая строка тоже.

Пример вывода:

```
True
True
True
False
False
False
```

Еще три интригующих примера:

```python
t = 'Six lambdas'
print(t.isalnum())

t = 'ΑβΓδ'
print(t.isalnum())

t = '20E1'
print(t.isalnum())

```

Запустите их и проверьте вывод.

Подсказка: причиной первого результата является пробел - это ни цифра, ни буква.


# Метод `isalpha()`


Метод `isalpha()` более специализирован - его интересуют только **буквы**.

```python
# Пример метода isapha():
print("Moooo".isalpha())
print('Mu40'.isalpha())

```

Посмотрите на пример - его вывод:

```
True
False
```

# Метод `isdigit()`


С другой стороны `isdigit()` метод ищет **только цифры** - любые другие данные приведут к возвращению `False`.

```python
# Пример метода isdigit()
print('2018'.isdigit())
print("Year2019".isdigit())

```

Рассмотрим пример - его вывод будет следующим:

```
True
False
```

Проведите больше экспериментов.


# Метод `islower()`


Метод `islower()` - вычурный вариант `isalpha()` - он принимает **только строчные буквы**.

```python
# Пример метода islower():
print("Moooo".islower())
print('moooo'.islower())

```

Посмотрите на пример - он выводит:

```
False
True
```


# Метод `isspace()`


Метод `isspace()` **идентифицирует только пробелы** - он игнорирует любой другой символ (в результате получается `False`).

```python
# Пример метода isspace():
print(' \n '.isspace())
print(" ".isspace())
print("mooo mooo mooo".isspace())

```

Посмотрите на пример - вывод:

```
True
True
False
```


# Метод `isupper()`


Метод `isupper()` является версией `islower()` в верхнем регистре - он концентрируется только на **только заглавных буквах**.

```python
# Пример метода isupper():
print("Moooo".isupper())
print('moooo'.isupper())
print('MOOOO'.isupper())

```

Опять же, посмотрите на код - пример дает следующий вывод:

```
False
False
True
```


# Метод `join()`


Метод `join()` довольно сложный, поэтому давайте подробно рассмотрим его:

*   как следует из его названия, метод **выполняет соединение** - он принимает один аргумент в виде списка; необходимо убедиться, что все элементы списка являются строками - в противном случае метод вызовет исключение `TypeError`;
*   все элементы списка будут **объединены в одну строку**, но...
*   ... строка, из которой был вызван метод, **используется в качестве разделителя** и помещается между объединенных строк;
*   вновь созданная строка возвращается в результате вызова.

```python
# Пример метода join():
print(",".join(["omicron", "pi", "rho"]))

```

Посмотрите на код. Давайте проанализируем его:

*   метод `join()` вызывается из строки, содержащей запятую (строка может быть произвольно длинной или пустой);
*   аргумент `join` - это список, содержащий три строки;
*   метод возвращает новую строку.

Вот она:

```
omicron,pi,rh
```


# Метод `lower()`


Метод `lower()` **создает копию исходной строки, заменяет все буквы в верхнем регистре их аналогами в нижнем регистре** и возвращает строку в качестве результата. Опять же, исходная строка остается нетронутой.

Если строка не содержит символов верхнего регистра, метод возвращает исходную строку.

Примечание. Метод `lower()` не принимает никаких параметров.

```python
# Пример метода lower():
print("SiGmA=60".lower())

```

Код в примере выводит:

```
sigma=60
```

А теперь, проведите свои собственные эксперименты.


# Метод `lstrip()`


Метод `lstrip()` без параметров **возвращает вновь созданную строку, сформированную из исходной, путем удаления всех начальных пробелов**.

```python
# Пример метода lstrip():
print("[" + " tau ".lstrip() + "]")

```

Проанализируйте пример кода.

Скобки не являются частью вывода - они показывают только границы результата.

Код выводит:

```
[tau ]
```

Метод `lstrip()` **с одним параметром** работает так же, как и его версия без параметров, но **удаляет все символы, включенные в его аргумент**, не только пробелы:

```python
print("www.nsalab.org".lstrip("w."))

```

Скобки здесь не нужны, так как результат выглядит следующим образом:

```
nsalab.org
```

Можете угадать вывод кода ниже? Хорошо подумайте. Запустите код и проверьте свои прогнозы.

```python
print("pythoninstitute.org".lstrip(".org"))

```

Удивлены? **Ведущие** символы, ведущие пробелы. Экспериментируйте со своими примерами.


# Метод `replace()`


Метод `replace()` **с двумя параметрами возвращает копию исходной строки, в которой все элементы, равняющиеся первому аргументу, заменяются вторым аргументом**.

```python
# Пример метода replace():
print("www.nsalab.org".replace("nsalab.org", "pythoninstitute.org"))
print("This is it!".replace("is", "are"))
print("Apple juice".replace("juice", ""))

```

Посмотрите на пример кода. Запустите его.

Код выводит:

```
www.pythoninstitute.org
Thare are it!
Apple
```

Второй аргумент может быть пустой строкой (тогда замена фактически удаляет все символы строки), но первый не может быть пустым.


Вариант `replace()` **с тремя параметрами** использует третий аргумент (число) для **ограничения количества замен**.

Посмотрите на приведенный ниже пример кода:

```python
print("This is it!".replace("is", "are", 1))
print("This is it!".replace("is", "are", 2))

```

Можете угадать его вывод? Запустите код и проверьте свои догадки.


# Метод `rfind()`


Метод с одним, двумя и тремя параметрами, называющийся `rfind()`, выполняет почти те же функции, что и его аналоги (те, которые не имеют префикса _r_), но **начинает поиск с конца строки**, а не с начала (отсюда и префикс _r_ от слова _right_).

```python
# Пример метода rfind():
print("tau tau tau".rfind("ta"))
print("tau tau tau".rfind("ta", 9))
print("tau tau tau".rfind("ta", 3, 9))

```

Посмотрите на пример кода и попытайтесь предсказать его вывод. Запустите код, чтобы проверить, были ли Вы правы.


# Метод `rstrip()`


Два варианта использования метода `rstrip()` почти не отличаются от `lstrip`, но **влияют на другой край строки**.

```python
# Пример метода rstrip():
print("[" + " upsilon ".rstrip() + "]")
print("nsalab.org".rstrip(".org"))

```

Посмотрите на пример кода. Можете ли Вы угадать его вывод? Запустите код, чтобы проверить свои догадки.

Как обычно, мы рекомендуем Вам поэкспериментировать с собственными примерами.


# Метод `split()`


Метод `split()` делает то, о чем говорит его название: он **разбивает строку и создает список всех обнаруженных подстрок**.

Метод **предполагает, что подстроки разделены пробелами** - пробелы не участвуют в операции и не копируются в результирующий список.

Если строка пуста, результирующий список тоже пуст.

```python
# Пример метода split():
print("phi       chi\npsi".split())

```

Посмотрите на код. В примере выдается следующий вывод:

```
['phi', 'chi', 'psi']
```

Примечание: обратная операция может быть выполнена методом `join()`.

  
# Метод `startswith()`


Метод `startwith()` является зеркальным отражением метода `endwith()` - он **проверяет, начинается ли данная строка с указанной подстроки**.

```python
# Пример метода startswith():
print("omega".startswith("meg"))
print("omega".startswith("om"))

```

Посмотрите на код. Вот его вывод:

```
False
True
```

# Метод strip()


Метод `strip()` объединяет эффекты, вызванные `rstrip()` и `lstrip()` - он **создает новую строку, в которой отсутствуют все начальные и конечные пробелы**.

```python
# Пример метода strip():
print("[" + "   aleph   ".strip() + "]")

```

Посмотрите на пример. Это результат, который он возвращает:

```
[aleph]
```


Теперь проведите собственные эксперименты с этими двумя методами.


# Метод `swapcase()`


Метод `swapcase()` **создает новую строку и меняет регистр всех букв в исходной строке**: символы нижнего регистра становятся заглавными, и наоборот.

Все остальные символы остаются неименными.

```python
# Пример метода swapcase():
print("I know that I know nothing.".swapcase())

```

Посмотрите на пример. Можете угадать вывод? Это не будет выглядеть очень красиво, но Вы должны это увидеть:

```
i KNOW THAT i KNOW NOTHING.
```


# Метод `title()`


Метод `title()` выполняет похожую функцию - он **переводит первую букву каждого слова в верхний регистр, превращая все остальные в строчные**.

```python
# Пример метода title():
print("I know that I know nothing. Part 1.".title())

```

Посмотрите на пример. Можете угадать вывод? Его результат:

```
I Know That I Know Nothing. Part 1.
```


# Метод `upper()`


И последний, но не менее важный: метод `upper()` **создает копию исходной строки, заменяет все строчные буквы их прописными аналогами** и возвращает строку как результат.

```python
# Пример метода upper():
print("I know that I know nothing. Part 2.".upper())

```

Посмотрите на пример. Он выводит:

```
I KNOW THAT I KNOW NOTHING. PART 2.
``` 

Мы дошли до конца этого раздела. Вы удивлены работой какого-либо из методов, которые мы обсуждали до этого момента? Потратьте пару минут, чтобы просмотреть их, и давайте перейдем к следующей части курса, где мы покажем Вам, какие замечательные вещи мы можем делать со строками.

  
# Основные тезисы


1. Некоторые из методов, предлагаемых строками:

   *   `capitalize()` – заменяет все строчные буквы на заглавные;
   *   `center()` – центрирует строку внутри поля известной длины;
   *   `count()` – считает появления данного символа в строке;
   *   `join()` – соединяет все предметы кортежа/списка в одну строку;
   *   `lower()` – преобразует все буквы строки в строчные;
   *   `lstrip()` – удаляет белые символы из всей строки;
   *   `replace()` – заменяет данную подстроку другой;
   *   `rfind()` – находит подстроку, поиск начинается с конца строки;
   *   `rstrip()` – удаляет белые символы начиная с конца строки;
   *   `split()` – разбивает строку на подстроки с использованием данного разделителя;
   *   `strip()` – удаляет белые символы в начале и конце строки;
   *   `swapcase()` – меняет регистр букв на обратный (нижний на верхний и наоборот)
   *   `title()` – делает первую букву в каждом слове заглавной;
   *   `upper()` – преобразует все буквы строки в буквы верхнего регистра.


2. Содержимое строки можно определить с помощью следующих методов (все они возвращают логические значения):

   *   `endswith()` - заканчивается ли строка заданной подстрокой?
   *   `isalnum()` - состоит ли строка только из букв и цифр?
   *   `isalpha()` - состоит ли строка только из букв?
   *   `islower()` - состоит ли строка только из строчных букв?
   *   `isspace()` - состоит ли строка только из белых символов?
   *   `isupper()` - состоит ли строка только из заглавных букв?
   *   `startswith()` - начинается ли строка с данной подстроки?

---

**Упражнение 1**

Каков ожидаемый вывод следующего кода?

```python
for ch in "abc123XYX":
    if ch.isupper():
        print(ch.lower(), end='')
    elif ch.islower():
        print(ch.upper(), end='')
    else:
        print(ch, end='')

```

<details><summary>Проверка</summary>

```
ABC123xyz
```

</details>

---

**Упражнение 2**

Каков ожидаемый вывод следующего кода?

```python
s1 = 'Where are the snows of yesteryear?'
s2 = s1.split()
print(s2[-2])

```
  
<details><summary>Проверка</summary>

```
of
```

</details>

---

**Упражнение 3**

Каков ожидаемый вывод следующего кода?

```python
the_list = ['Where', 'are', 'the', 'snows?']
s = '*'.join(the_list)
print(s)

```

<details><summary>Проверка</summary>

```
Where*are*the*snows?
```

</details>

---

**Упражнение 4**

Каков ожидаемый вывод следующего кода?

```python
s = 'It is either easy or impossible'
s = s.replace('easy', 'hard').replace('im', '')
print(s)

```

<details><summary>Проверка</summary>

```
It is either hard or possible
```

</details>


