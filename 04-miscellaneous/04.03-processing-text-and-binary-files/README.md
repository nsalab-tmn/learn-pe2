# Обработка текстовых файлов

На этом уроке мы подготовим [простой текстовый файл](./assets/tzop.txt) с небольшим, простым содержанием.

Мы собираемся показать Вам некоторые основные приемы, которые Вы можете использовать для **чтения содержимого файла** и его обработки.

Обработка будет очень простой - Вы скопируете содержимое файла в консоль и посчитаете все символы, которые считала программа.

Но помните - наше понимание текстового файла очень строго. В нашем смысле это простой текстовый файл - он может содержать только текст без каких-либо дополнительных декораций (форматирование, разные шрифты и т.д.).

Вот почему Вы должны избегать создания файла с использованием любого продвинутого текстового процессора, такого как MS Word, LibreOffice Writer или чего-то подобного. Используйте базовые редакторы, которые предлагает ваша ОС: Блокнот, vim, gedit и т.д.

Если Ваши текстовые файлы содержат некоторые национальные символы, не включенные в стандартную кодировку ASCII, Вам может потребоваться дополнительный шаг. При вызове функции `open()` может потребоваться аргумент, обозначающий конкретную кодировку текста.

Например, если Вы используете ОС Unix/Linux, настроенную на использование UTF-8 в качестве общесистемного параметра, функция open() может выглядеть следующим образом:

```python
stream = open('file.txt', 'rt', encoding='utf-8')

```  

где аргумент кодирования должен быть установлен в значение, представляющее собой строку, представляющую правильную кодировку текста (здесь UTF-8).

Обратитесь к документации по Вашей ОС, чтобы найти имя кодировки, соответствующее Вашей среде.


**Примечание**

Для целей наших экспериментов с обработкой файлов, проводимых в этом разделе, мы будем использовать предварительно загруженный набор файлов (например, [tzop.txt](./assets/tzop.txt) или [text.txt](./assets/text.txt) файлы), с которыми Вы сможете работать. Если Вы хотите работать со своими собственными файлами локально на своем компьютере, мы настоятельно рекомендуем Вам сделать это и использовать IDLE для проведения собственных тестов.

Чтение содержимого текстового файла может быть выполнено несколькими различными способами - ни один из них не лучше и не хуже, чем любой другой. Вам решать, какой из них Вы предпочитаете.

Некоторые из них иногда будут удобнее, а некоторые не очень. Важно быть гибким. Не бойтесь менять свои предпочтения.

Самым основным из этих методов является тот, который предлагается функцией `read()`, которую Вы могли увидеть в действии на предыдущем уроке.

Применительно к текстовому файлу функция может:

*   прочитать желаемое количество символов (включая только один) из файла и вернуть их в виде строки;
*   прочитать все содержимое файла и вернуть его в виде строки;
*   если больше нечего читать (виртуальная считывающая головка достигает конца файла), функция возвращает пустую строку.

Мы начнем с самого простого варианта и используем файл с именем [text.txt](./assets/text.txt). Файл имеет следующее содержимое:

```
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
```

Теперь посмотрите на код, и давайте проанализируем его.

```python
from os import strerror

try:
    cnt = 0
    s = open('text.txt', "rt")
    ch = s.read(1)
    while ch != '':
        print(ch, end='')
        cnt += 1
        ch = s.read(1)
    s.close()
    print("\n\nCharacters in file:", cnt)
except IOError as e:
    print("I/O error occurred: ", strerr(e.errno))

```

Процедура довольно проста:

*   используйте механизм `try-except` и откройте файл с заранее заданным именем (в нашем случае `text.txt`);
*   попытайтесь прочитать самый первый символ из файла (`ch = s.read(1)`);
*   если Вы добились успеха (это подтверждается положительным результатом проверки условия `while`), выведите символ (обратите внимание на аргумент `end=` - это важно! Вы же не хотите переходить на новую строку после каждого символа "!");
*   также не забудьте обновить счетчик (`cnt`);
*   попробуйте прочитать следующий символ и повторите процесс.

Если Вы абсолютно уверены, что длина файла безопасна, и Вы можете сразу считать весь файл в память, Вы можете сделать это - функция `read()`, вызываемая без каких-либо аргументов или с аргументом, который является `None`, выполнит эту работу за Вас.

Помните - **чтение файла длиной в терабайты с использованием этого метода может привести к повреждению вашей ОС**.

Не ожидайте чудес - память компьютера не растягивается.

Посмотрите на код. Что Вы думаете об этом?

```python
from os import strerror

try:
    counter = 0
    stream = open('text.txt', "rt")
    content = stream.read()
    for char in content:
        print(char, end='')
        counter += 1
    stream.close()
    print("\n\nCharacters in file:", counter)
except IOError as e:
    print("I/O error occurred: ", strerr(e.errno))

```

Давайте проанализируем это:

*   откройте файл как ранее;
*   прочтите его содержимое одним вызовом функции `read()`;
*   затем обработайте текст, повторяя его с помощью обычного цикла `for` и обновляя значение счетчика при каждом повторе цикла.

Результат будет точно таким же, как и ранее.


# Обработка текстовых файлов: `readline()`

Если Вы хотите обрабатывать содержимое файла **как набор строк**, а не как набор символов, метод `readline()` поможет Вам в этом.

Метод пытается **прочитать целую строку текста из файла** и возвращает ее в виде строки в случае успеха. В противном случае он возвращает пустую строку.

Это открывает новые возможности - теперь Вы также можете легко считать строки, а не только символы.

Давайте используем это. Посмотрите на код.

```python
from os import strerror

try:
    character_counter = line_counter = 0
    stream = open('text.txt', 'rt')
    line = stream.readline()
    while line != '':
        line_counter += 1
        for char in line:
            print(char, end='')
            character_counter += 1
        line = stream.readline()
    stream.close()
    print("\n\nCharacters in file:", character_counter)
    print("Lines in file:     ", line_counter)
except IOError as e:
    print("I/O error occurred:", strerror(e.errno))

```

Как видите, общая идея точно такая же, как в обоих предыдущих примерах.


# Обработка текстовых файлов: `readlines()`

Другой метод, который обрабатывает текстовый файл как набор строк, а не символов - это `readlines()`.

Метод `readlines()` при вызове без аргументов пытается **считать все содержимое файла и возвращает список строк, по одному элементу на строку файла**.

Если Вы не уверены, что размер файла достаточно мал и не хотите испытывать ОС, Вы можете убедить метод `readlines()` прочитать не более указанного числа байт сразу (возвращаемое значение остается прежним - это список строк).

Не стесняйтесь экспериментировать с примером кода для понимания того, как метод `readlines()` работает:

```python
stream = open("text.txt")
print(stream.readlines(20))
print(stream.readlines(20))
print(stream.readlines(20))
print(stream.readlines(20))
stream.close()

```

**Максимально допустимый размер входного буфера передается методу в качестве аргумента**.

Вы можете ожидать, что `readlines()` может обрабатывать содержимое файла более эффективно, чем `readline()`, так как это может требовать меньшего количества вызовов.

Примечание: когда нечего читать из файла, метод возвращает пустой список. Используйте его, чтобы определить конец файла.

Что касается размера буфера, Вы можете ожидать, что его увеличение может улучшить производительность ввода, но золотого правила для этого нет - попробуйте найти оптимальные значения самостоятельно.

Посмотрите на код. Мы изменили его, чтобы показать Вам, как использовать `readlines()`.

```python
from os import strerror

try:
    character_counter = line_counter = 0
    stream = open('text.txt', 'rt')
    lines = stream.readlines(20)
    while len(lines) != 0:
        for line in lines:
            line_counter += 1
            for char in line:
                print(char, end='')
                character_counter += 1
        lines = stream.readlines(10)
    stream.close()
    print("\n\nCharacters in file:", character_counter)
    print("Lines in file:     ", line_counter)
except IOError as e:
    print("I/O error occurred:", strerror(e.errno))

```

Мы решили использовать 15-байтовый буфер. Не думайте, что это рекомендация.

Мы использовали такое значение, чтобы избежать ситуации, когда первый вызов `readlines()` использует весь файл.

Мы хотим, чтобы метод мог работать усерднее и демонстрировал свои возможности.

В коде есть **два вложенных цикла**: внешний использует результат `readlines()` для его итерации, а внутренний печатает строки символов.

Последний пример, который мы хотим представить, показывает очень интересную черту объекта, возвращаемого функцией `open()` в текстовом режиме.

Мы думаем, что это может Вас удивить - **объект является экземпляром итерируемого класса**.

Странно? Ничуть. Полезно? Да, очень.

**Протокол итерации, определенный для файлового объекта**, очень прост - его метод `__next__` просто **возвращает следующую строку, прочитанную из файла**.

Более того, Вы можете ожидать, что объект автоматически вызовет `close()`, когда любой из прочитанных файлов достигнет конца файла.

Посмотрите, насколько простым и понятным теперь стал код.

```python
from os import strerror

try:
	character_counter = line_counter = 0
	for line in open('text.txt', 'rt'):
		line_counter += 1
		for char in line:
			print(char, end='')
			character_counter += 1
	print("\n\nCharacters in file:", character_counter)
	print("Lines in file:     ", line_counter)
except IOError as e:
	print("I/O error occurred: ", strerror(e.errno))

```


# Работа с текстовыми файлами: `write()`

Написание текстовых файлов кажется более простым, поскольку на самом деле существует один метод, который можно использовать для выполнения такой задачи.

Метод называется `write()` и принимает только один аргумент - строку, которая будет передана в открытый файл (не забывайте, что режим открытия должен отражать способ, которым перенесены данные - **запись файла, открытого в режиме чтения, не удастся**).

Символ новой строки не добавляется в аргумент `write()`, поэтому Вы должны добавить его самостоятельно, если хотите, чтобы файл был заполнен несколькими строками.

Пример показывает очень простой код, который создает файл с именем `newtext.txt` (примечание: открытый режим `w` гарантирует, что **файл будет создан с нуля**, даже если он существует и содержит данные), а затем помещает в него десять строк.

```python
from os import strerror

try:
	file = open('newtext.txt', 'wt') # A new file (newtext.txt) is created.
	for i in range(10):
		s = "line #" + str(i+1) + "\n"
		for char in s:
			file.write(char)
	file.close()
except IOError as e:
	print("I/O error occurred: ", strerror(e.errno))

```

Строка для записи состоит из строки слова, за которой следует номер строки. Мы решили писать содержимое строки символ за символом (это делается внутренним циклом `for`), но вы не обязаны делать это таким образом.

Мы просто хотели показать Вам, что `write()` может работать с отдельными символами.

Код создает файл, заполненный следующим текстом:

```
line #1
line #2
line #3
line #4
line #5
line #6
line #7
line #8
line #9
line #10
```

Можете ли Вы вывести содержимое файла в консоль?

Мы рекомендуем Вам проверить поведение метода `write()` локально на вашем компьютере.

Посмотрите на пример. Мы изменили предыдущий код, чтобы записать целые строки в текстовый файл.

```python
from os import strerror

try:
    file = open('newtext.txt', 'wt')
    for i in range(10):
        file.write("line #" + str(i+1) + "\n")
    file.close()
except IOError as e:
    print("I/O error occurred: ", strerror(e.errno))

```

Содержимое вновь созданного файла такое же.

Примечание: Вы можете использовать тот же метод для записи в поток `stderr`, но не пытайтесь открыть его, так как он всегда открыт неявно.

Например, если Вы хотите отправить строку сообщения в `stderr`, чтобы отличить ее от обычного вывода программы, это может выглядеть так:

```python
import sys
sys.stderr.write("Error message")

```

  
## Что такое байтовый массив?

Прежде чем мы начнем говорить о двоичных файлах, мы должны рассказать Вам об одном из **специализированных классов, которые Python использует для хранения аморфных данных**.

**Аморфные данные - это данные, которые не имеют определенной формы** - это просто последовательность байтов.

Это не означает, что эти байты не могут иметь своего собственного значения или не могут представлять какой-либо полезный объект, например, растровую графику.

Наиболее важным аспектом этого является то, что в том месте, где мы контактируем с данными, мы не можем или просто не хотим ничего о них знать.

Аморфные данные не могут быть сохранены с использованием любого из ранее представленных средств - они не являются ни строками, ни списками.

Должен быть специальный контейнер, способный обрабатывать такие данные.

В Python есть несколько таких контейнеров - один из них **специализированное имя класса bytearray** - как следует из названия, это **массив, содержащий (аморфные) байты**.

Если Вы хотите иметь такой контейнер, например, чтобы читать растровое изображение и обрабатывать его любым способом, Вам нужно создать его явно, используя один из доступных конструкторов.

Посмотрите:

```python
data = bytearray(10)
```  

Такой вызов создает объект `bytearray`, способный хранить десять байтов.

Примечание: такой конструктор **заполняет весь массив нулями**.

Байт-массивы напоминают списки во многих отношениях. Например, они **изменяемы**, они являются субъектом функции `len()`, и Вы можете получить доступ к любому из их элементов с помощью обычной индексации.

Есть одно важное ограничение - **Вы не должны присваивать элементам байтового массива значения, которые не являются целыми числами** (нарушение этого правила приведет к исключению `TypeError`), и Вам **не разрешено присваивать значение, которое не входит в диапазон от 0 до 255 включительно** (если Вы не хотите вызвать исключение `ValueError`).

Вы можете **рассматривать любые элементы байтового массива как целочисленные значения** - как в примере в редакторе.

Примечание: мы использовали два метода для итерации байтовых массивов и использовали функцию `hex()`, чтобы элементы печатались в виде шестнадцатеричных значений.

Теперь мы покажем вам, **как записать байтовый массив в двоичный файл**, поскольку мы не хотим сохранять его читаемое представление - мы хотим записать копию один в один содержимого физической памяти, побайтно.

Итак, как нам записать байтовый массив в двоичный файл?

Посмотрите на код.

```python
from os import strerror

data = bytearray(10)

for i in range(len(data)):
    data[i] = 10 + i

try:
    binary_file = open('file.bin', 'wb')
    binary_file.write(data)
    binary_file.close()
except IOError as e:
    print("I/O error occurred:", strerror(e.errno))

```

Давайте проанализируем его:


*   сначала мы инициализируем `bytearray` с последующими значениями, начиная с `10`;

    если Вы хотите, чтобы содержимое файла было легко читаемым, замените 10 чем-то вроде ord('a') - это приведет к получению байтов, содержащих значения, соответствующие алфавитной части ASCII-код (не думайте, что он превратит файл в текстовый файл - он все еще двоичный, так как он был создан с флагом wb);

*   затем мы создаем файл с помощью функции `open()` - единственное отличие по сравнению с предыдущими вариантами - это режим открытия, содержащий флаг `b`;

*   метод `write()` принимает свой аргумент (`bytearray`) и отправляет его (целиком) в файл;

*   поток затем закрывается обычным способом.

Метод `write()` возвращает количество успешно записанных байтов.

Если значения отличаются от длины аргументов метода, это может привести к некоторым ошибкам записи.

В этом случае мы не использовали результат, но это может не сработать в некоторых случаях.

Попробуйте запустить код и проанализировать содержимое вновь созданного выходного файла.

Вы будете использовать его на следующем шаге.


## Как читать байты из потока

Чтение из бинарного файла требует использования специального метода с именем `readinto()`, так как метод не создает новый объект байтового массива, но заполняет ранее созданный объект значениями, взятыми из бинарного файла.

Примечание:

*   метод возвращает количество успешно прочитанных байтов;
*   метод пытается заполнить все пространство, доступное внутри аргумента; если в файле больше данных, чем места в аргументе, операция чтения остановится до конца файла; в противном случае результат метода может указывать на то, что байтовый массив был заполнен только фрагментарно (результат также покажет, что часть массива, не используемая вновь прочитанным содержимым, останется нетронутой).

Посмотрите на полный код ниже:

```python
from os import strerror

data = bytearray(10)

try:
    binary_file = open('file.bin', 'rb')
    binary_file.readinto(data)
    binary_file.close()

    for b in data:
        print(hex(b), end=' ')
except IOError as e:
    print("I/O error occurred:", strerror(e.errno))

```

Давайте проанализируем его:

*   сначала мы открываем файл (тот, который Вы создали с помощью предыдущего кода) в режиме, описанном как `rb`;
*   затем мы читаем его содержимое в байтовый массив с именем `data`, размером десять байтов;
*   наконец, мы печатаем содержимое байтового массива - так как мы ожидали.

Запустите код и проверьте, работает ли он.


# Как читать байты из потока

Альтернативный способ чтения содержимого двоичного файла предлагает метод с именем `read()`.

Вызванный без аргументов, он пытается **прочитать все содержимое файла в память**, сделав их частью вновь созданного объекта класса `bytes`.

Этот класс имеет некоторые сходства с `bytearray`, за исключением одного существенного различия - он **неизменный**.

К счастью, нет никаких препятствий для создания байтового массива путем получения его начального значения непосредственно из объекта байтов, как здесь:

```python
from os import strerror

try:
    binary_file = open('file.bin', 'rb')
    data = bytearray(binary_file.read())
    binary_file.close()

    for b in data:
        print(hex(b), end=' ')

except IOError as e:
    print("I/O error occurred:", strerror(e.errno))

```

Будьте осторожны - **не используйте этот тип чтения, если Вы не уверены, что содержимое файла будет соответствовать доступной памяти**.

Если метод `read()` вызывается с аргументом, он **указывает максимальное количество байтов для чтения**.

Метод пытается прочитать желаемое количество байтов из файла, а длину возвращаемого объекта можно использовать для определения количества фактически прочитанных байтов.

Вы можете использовать метод так же, как здесь:

```python
try:
    binary_file = open('file.bin', 'rb')
    data = bytearray(binary_file.read(5))
    binary_file.close()

    for b in data:
        print(hex(b), end=' ')

except IOError as e:
    print("I/O error occurred:", strerror(e.errno))

```

Примечание: первые пять байтов файла были прочитаны кодом - следующие пять все еще ожидают обработки.


# Копирование файлов - простой и функциональный инструмент

Теперь Вы собираетесь объединить все эти новые знания, добавить в него некоторые свежие элементы и использовать его для написания реального кода, способного фактически копировать содержимое файла.

Конечно, цель состоит не в том, чтобы сделать лучшую замену таким командам, как _copy_ (MS Windows) или _cp_ (Unix/Linux), а в том, чтобы найти один из возможных путей создания рабочего инструмента, даже если никто не хочет его использовать.

Посмотрите на код.

```python
from os import strerror

source_file_name = input("Enter the source file name: ")
try:
    source_file = open(source_file_name, 'rb')
except IOError as e:
    print("Cannot open the source file: ", strerror(e.errno))
    exit(e.errno)	

destination_file_name = input("Enter the destination file name: ")
try:
    destination_file = open(destination_file_name, 'wb')
except Exception as e:
    print("Cannot create the destination file: ", strerror(e.errno))
    source_file.close()
    exit(e.errno)	

buffer = bytearray(65536)
total  = 0
try:
    readin = source_file.readinto(buffer)
    while readin > 0:
        written = destination_file.write(buffer[:readin])
        total += written
        readin = source_file.readinto(buffer)
except IOError as e:
    print("Cannot create the destination file: ", strerror(e.errno))
    exit(e.errno)	
    
print(total,'byte(s) succesfully written')
source_file.close()
destination_file.close()

```

Давайте проанализируем его:

*   строки с 3 по 8: спросить у пользователя имя файла для копирования и попробовать открыть его для чтения; прекратить выполнение программы, если открытие не удалось; примечание: используйте функцию `exit()`, чтобы остановить выполнение программы и передать код завершения в ОС; любой код завершения, кроме `0`, говорит о том, что в программе возникли некоторые проблемы; используйте значение `errno`, чтобы указать природу проблемы;
*   строки с 10 по 16: повторить то же самое действие, но на этот раз для выходного файла;
*   строка 18: подготовить фрагмент памяти для передачи данных из исходного файла в целевой; такая область передачи часто называется буфером, отсюда и название переменной; размер буфера произвольный - в этом случае мы решили использовать 64 килобайта; технически, больший буфер быстрее копирует элементы, так как больший буфер означает меньше операций ввода-вывода; на самом деле, всегда есть предел, пересечение которого не дает дальнейших улучшений; проверьте сами, если хотите.
*   строка 19: считать скопированные байты - это счетчик и его начальное значение;
*   строка 21: попытаться заполнить буфер в первый раз;
*   строка 22: пока Вы получаете ненулевое число байтов, повторяйте те же действия;
*   строка 23: записать содержимое буфера в выходной файл (примечание: мы использовали фрагмент, чтобы ограничить количество записываемых байтов, так как `write()` всегда предпочитает записывать весь буфер);
*   строка 24: обновить счетчик;
*   строка 25: считать следующий фрагмент файла;
*   строки с 30 по 32: некоторая окончательная очистка - работа выполнена.


# Основные тезисы

1. Чтобы прочитать содержимое файла, можно использовать следующие методы потока:

   *   `read(number)` – считывает `number` символов/байтов из файла и возвращает их в виде строки; может читать весь файл сразу;
   *   `readline()` – читает одну строку из текстового файла;
   *   `readlines(number)` – читает `number` строк из текстового файла; умеет читать сразу все строки;
   *   `readinto(bytearray)` – читает байты из файла и заполняет ими `bytearray`;


2. Чтобы записать новое содержимое в файл, можно использовать следующие методы потока:

   *   `write(string)` – записывает `string` в текстовый файл;
   *   `write(bytearray)` – записывает все байты `bytearray` в файл;


3. Метод `open()` возвращает итерируемый объект, который можно использовать для итерации по всем строкам файла внутри цикла `for`. Например:
    
    ```python
    for line in open("file", "rt"):
        print(line, end='')
    
    ```
    
    Код построчно копирует содержимое файла в консоль.
    
    **Примечание**: поток закрывается **автоматически**, когда достигает конца файла.

  
---

**Упражнение 1**

Чего мы ожидаем от метода `readlines()`, когда поток связан с пустым файлом?

<details><summary>Проверка</summary>

Пустой список (список с нулевой длиной).

</details>

---

**Упражнение 2**

Для чего предназначен следующий код?

```python
for line in open("file", "rt"):
    for char in line:
        if char.lower() not in "aeiouy ":
            print(char, end='')

```

<details><summary>Проверка</summary>

Он копирует содержимое _файла_ на консоль, игнорируя все гласные.

</details>

---

**Упражнение 3**

Вы собираетесь обработать растровое изображение, хранящееся в файле с именем `image.png`, и хотите прочитать его содержимое целиком в переменную _bytearray_ с именем `image`. Добавьте строку в следующий код для достижения этой цели.

```python
try:
    stream = open("image.png", "rb")
    # Добавьте строку здесь.
    stream.close()
except IOError:
    print("failed")
else:
    print("success")

```

<details><summary>Проверка</summary>

```python
image = bytearray(stream.read())
```

</details>

